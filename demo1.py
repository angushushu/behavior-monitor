# Form implementation generated from reading ui file 'demo1.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PySide6 import QtCore, QtGui, QtWidgets
from PySide6.QtWidgets import QMessageBox
import components
import sqlite3
from datetime import date
import numpy as np

# Create a database/connect to one
conn = sqlite3.connect('list.db')
# Create a cursor
c = conn.cursor()
# Create table todo_list w/ coln list_item
c.execute("""CREATE TABLE if not exists tasks(
    taskid INTEGER PRIMARY KEY AUTOINCREMENT,
    task TEXT
    )
    """)
c.execute("""CREATE TABLE if not exists records(
    date TEXT,
    task INTEGER,
    time INTEGER,
    FOREIGN KEY(task) REFERENCES tasks(taskid)
    )
    """)
# Commit the changes
conn.commit()
conn.close()

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        # for timing
        self.steps = dict()
        self.date = date.today()
        self.tasks = self.get_tasks()
        print(type(self.date))
        print(self.date)

        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(698, 390)
        self.centralwidget = QtWidgets.QWidget(parent=MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.centralwidget)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.tabs = QtWidgets.QTabWidget(parent=self.centralwidget)
        self.tabs.setObjectName("tabs")
        self.tab_1 = QtWidgets.QWidget()
        self.tab_1.setObjectName("tab1")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.tab_1)
        self.gridLayout_2.setObjectName("gridLayout_2")

        self.add_btn = QtWidgets.QPushButton(parent=self.tab_1, clicked=lambda:self.add_it(self.task_edit.text(),0))
        self.add_btn.setObjectName("add_btn")
        self.gridLayout_2.addWidget(self.add_btn, 0, 1, 1, 1)
        self.clr_btn = QtWidgets.QPushButton(parent=self.tab_1, clicked=self.clear_it)
        self.clr_btn.setObjectName("clr_btn")
        self.gridLayout_2.addWidget(self.clr_btn, 0, 3, 1, 1)
        self.rmv_btn = QtWidgets.QPushButton(parent=self.tab_1, clicked=self.remove_it)
        self.rmv_btn.setObjectName("rmv_btn")
        self.gridLayout_2.addWidget(self.rmv_btn, 0, 2, 1, 1)
        self.task_list = QtWidgets.QListWidget(parent=self.tab_1)
        self.task_list.setObjectName("task_list")
        self.gridLayout_2.addWidget(self.task_list, 1, 0, 1, 5)
        self.save_btn = QtWidgets.QPushButton(parent=self.tab_1, clicked=self.save_it)
        self.save_btn.setObjectName("save_btn")
        self.gridLayout_2.addWidget(self.save_btn, 0, 4, 1, 1)
        self.task_edit = QtWidgets.QLineEdit(parent=self.tab_1)
        self.task_edit.setObjectName("task_edit")
        self.gridLayout_2.addWidget(self.task_edit, 0, 0, 1, 1)
        self.tabs.addTab(self.tab_1, "")
        self.tab_2 = QtWidgets.QWidget()
        self.tab_2.setObjectName("tab_2")
        # self.tabs.tabBarClicked.connect(self.update_records)

        self.gridLayout_3 = QtWidgets.QGridLayout(self.tab_2)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.comboBox = components.CheckableComboBox(parent=self.tab_2)
        self.comboBox.setObjectName("comboBox")
        self.comboBox.popupAboutToBeShown.connect(self.update_tasks)
        print(self.tasks)

        self.gridLayout_3.addWidget(self.comboBox, 0, 0, 1, 2)
        self.set_btn = QtWidgets.QPushButton(parent=self.tab_2, clicked=self.set_it)
        self.set_btn.setObjectName("set_btn")
        self.gridLayout_3.addWidget(self.set_btn, 0, 2, 1, 1)
        self.tableWidget = QtWidgets.QTableWidget(0, 0, parent=self.tab_2)
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setEditTriggers(QtWidgets.QAbstractItemView.NoEditTriggers)
        # self.tableWidget.verticalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)
        # self.tableWidget.setColumnCount(0)
        # self.tableWidget.setRowCount(0)
        self.gridLayout_3.addWidget(self.tableWidget, 1, 0, 1, 3)
        self.tabs.addTab(self.tab_2, "")
        self.horizontalLayout.addWidget(self.tabs)
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(parent=MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 698, 22))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(parent=MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        self.retranslateUi(MainWindow)
        self.tabs.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
        # Grab all item from db
        self.grab_all()

    def get_tasks(self):
        # pass
        conn = sqlite3.connect('list.db')
        c = conn.cursor()
        c.execute(f"""
            SELECT tasks.taskid, tasks.task
            FROM tasks
        """)
        res = c.fetchall()
        conn.commit()
        conn.close()
        return res
    
    def update_tasks(self):
        print('updating')
        self.tasks = self.get_tasks()
        task_names = [task[1] for task in self.tasks]
        self.comboBox.clear()
        self.comboBox.addItems(task_names)

    def set_it(self):
        # get tasks
        selected = self.comboBox.currentData()
        print(selected)
        # gain records
        if len(selected) > 0:
            conn = sqlite3.connect('list.db')
            cur = conn.cursor()
            cur.execute(f"""
                SELECT tasks.task, records.task, records.date, records.time
                FROM tasks, records
                WHERE tasks.taskid=records.task AND tasks.task IN {str(tuple(selected))}
            """)
            res = cur.fetchall()
            cur.execute(f"""
                SELECT records.date
                FROM records
            """)
            dates = cur.fetchall()
            print(dates)
            conn.commit()
            conn.close()
            # return res
            print(res)
            # res [('1', 1, '2023-05-12', 10), ('2', 2, '2023-05-12', 2)]
            self.tableWidget.setColumnCount(len(selected)+2)
            # self.tableWidget.setRowCount(0)
            date_total = dict()
            for i in res:
                if i[2] in date_total:
                    date_total[i[2]] += i[3]
                else:
                    date_total[i[2]] = i[3]
            table_data = np.zeros((len(date_total), len(selected)), dtype='float64')
            for r in res:
                table_data[list(date_total).index(r[2])][selected.index(r[0])] = r[3]
            temp = np.array([list(date_total.values())])
            print('temp',temp)
            print('table_data',table_data)
            table_data = np.concatenate((table_data, temp.T), axis=1)
            col_max = table_data.max(axis=0)
            print('table',table_data)
            print('col_max',col_max)
            ratio_data = np.divide(table_data, col_max, out=np.zeros_like(table_data), where=col_max!=0)
            ratio_data *= 100
            print(ratio_data)
            print(ratio_data.shape)
            if ratio_data.shape[1] < 5:
                self.tableWidget.horizontalHeader().setSectionResizeMode(QtWidgets.QHeaderView.Stretch)

            delegate = components.ProgressDelegate(self.tableWidget)
            for c in range(0, len(selected)+1):
                self.tableWidget.setItemDelegateForColumn(c+1, delegate)
            self.tableWidget.setHorizontalHeaderLabels(['Date']+selected+['Total'])
            for r in range(len(date_total)):
                self.tableWidget.insertRow(self.tableWidget.rowCount())
                print('row:',r)
                print(list(date_total.keys())[r])
                date_val = QtWidgets.QTableWidgetItem(list(date_total.keys())[r])
                self.tableWidget.setItem(r, 0, date_val)
                for c in range(0, len(selected)+1):
                    progress = QtWidgets.QTableWidgetItem()
                    progress.setData(QtCore.Qt.UserRole+1000, ratio_data[r][c])
                    self.tableWidget.setItem(r, c+1, progress)

    # Grab all item form db
    def grab_all(self):
        # Create a database/connect to one
        conn = sqlite3.connect('list.db')
        # Create a cursor
        c = conn.cursor()
        tasks = self.get_tasks()
        print('tasks', tasks)
        c.execute(f"""
            SELECT tasks.taskid, tasks.task, records.date, records.time
            FROM tasks, records
            WHERE records.date="{str(self.date)}" AND tasks.taskid=records.task
        """)
        records = c.fetchall()
        print('records',records)
        # Commit the changes
        conn.commit()
        conn.close()
        if len(records) < 1:
            return
        existing_tasks = []
        for r in records:
            print(r)
            # self.task_list.addItem(str(r[0]))
            existing_tasks.append(r[0])
            if r[2] == str(self.date):
                self.add_it(r[1],r[3])
        remain_tasks = [t for t in tasks if t[0] not in existing_tasks]
        for t in remain_tasks:
            self.add_it(t[1],0)
        self.update_step_display()
        self.update_ratio()

    # Add todo
    def add_it(self, name, step):
        print(self.task_edit.text())
        txt = name
        if txt in self.steps.keys():
            msg = QMessageBox()
            msg.setWindowTitle("Repeated")
            msg.setText("The task already exists")
            msg.setIcon(QMessageBox.Warning)
            x = msg.exec()
            return
        self.task_edit.clear()
        item = QtWidgets.QListWidgetItem()
        task = components.taskRecorder(self.steps)
        self.steps[txt] = step
        task.step = step
        task.btn.clicked.connect(lambda:self.start_stop(task))
        task.set_name(txt)
        self.task_list.addItem(item)
        self.task_list.setItemWidget(item, task)

    # Remove todo
    def remove_it(self):
        selected = self.task_list.currentRow()
        if selected < 0:
            msg = QMessageBox()
            msg.setWindowTitle("No Selection")
            msg.setText("Select one task first")
            msg.setIcon(QMessageBox.Warning)
            x = msg.exec()
            return
        msg = QMessageBox()
        msg.setWindowTitle("Remove?")
        ret = msg.question(self.tab_2, '', "This will remove all records of the task")
        msg.setIcon(QMessageBox.Warning)
        if ret == QMessageBox.No:
            return
        # self.task_edit.setText(str(selected))
        remove = self.task_list.itemWidget(self.task_list.item(selected)).label.text()
        self.task_list.takeItem(selected)
        self.steps.pop(remove)
        # delete db
        conn = sqlite3.connect('list.db')
        c = conn.cursor()
        c.execute(f"""
            SELECT taskid from tasks where task="{remove}"
        """)
        remove_id = c.fetchone()
        c.execute(f"""
            DELETE FROM tasks WHERE taskid={remove_id[0]}
        """)
        c.execute(f"""
            DELETE FROM records WHERE task={remove_id[0]}
        """)
        conn.commit()
        conn.close()

    # Clear all
    def clear_it(self):
        msg = QMessageBox()
        msg.setWindowTitle("Clear?")
        ret = msg.question(self.tab_2, '', "This will remove all records from the database")
        msg.setIcon(QMessageBox.Warning)
        if ret == QMessageBox.No:
            return
        print('clearning')
        self.task_list.clear()
        conn = sqlite3.connect('list.db')
        c = conn.cursor()
        c.execute(f"""
            DELETE FROM tasks
        """)
        c.execute(f"""
            DELETE FROM records
        """)
        conn.commit()
        conn.close()

    # Save to db
    def save_it(self):
        conn = sqlite3.connect('list.db')
        c = conn.cursor()
        # Clear db table
        c.execute(f"""
            DELETE FROM records
            WHERE date="{str(self.date)}";
        """,)
        for i in range(self.task_list.count()):
            task_name = self.task_list.itemWidget(self.task_list.item(i)).label.text()
            print('task_name', task_name)
            c.execute(f"""
                SELECT EXISTS(SELECT taskid from tasks where task="{task_name}")
            """)
            if c.fetchone()[0] == 0:
                # set new id
                c.execute(f"""
                    INSERT INTO tasks (task)
                    VALUES ("{task_name}")
                """)
            c.execute(f"""
                SELECT taskid from tasks where task="{task_name}"
            """)
            res = c.fetchone()
            task_id = res[0]
            print(task_id)
            c.execute("""INSERT INTO records VALUES 
                (:date,:task,:time)
            """,
                {
                    'date': str(self.date),
                    'task': task_id,
                    'time': self.task_list.itemWidget(self.task_list.item(i)).step
                })

        conn.commit()
        conn.close()
        msg = QMessageBox()
        msg.setWindowTitle("Succeed")
        msg.setText("Records saved into database")
        msg.setIcon(QMessageBox.Information)
        x = msg.exec()
    
    def start_stop(self, task):
        if not task.timer.isActive():
            task.btn.setText('stop')
            task.timer.start(1000)
        else:
            task.btn.setText('start')
            task.timer.stop()
            self.steps[task.label.text()] = task.step
            self.update_ratio()

    def update_step_display(self):
        for i in range(self.task_list.count()):
            t = self.task_list.itemWidget(self.task_list.item(i))
            t.duration.setText(str(t.step))

    def update_ratio(self):
        print(self.steps)
        max_step = max(self.steps.values())
        for i in range(self.task_list.count()):
            t = self.task_list.itemWidget(self.task_list.item(i))
            if max_step == 0:
                t.progress.setValue(0)
            else:
                t.progress.setValue(int(100*(float(t.step)/max_step)))

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "TaskMonitor"))
        self.add_btn.setText(_translate("MainWindow", "Add"))
        self.clr_btn.setText(_translate("MainWindow", "Clear"))
        self.rmv_btn.setText(_translate("MainWindow", "Remove"))
        self.save_btn.setText(_translate("MainWindow", "Save"))
        self.set_btn.setText(_translate("MainWindow", "Set"))
        self.tabs.setTabText(self.tabs.indexOf(self.tab_1), _translate("MainWindow", "Today"))
        self.tabs.setTabText(self.tabs.indexOf(self.tab_2), _translate("MainWindow", "Across days"))

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec())
